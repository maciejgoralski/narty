<!DOCTYPE html>

<html>

<head>
    <title>NaNarty</title>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="stats.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="divStats">
</div>

<div id="divGame">
</div>

<script type="text/javascript">

    var sceMain;
    var camMain;
    var renMain;

    function init() {

        var bulStats = true;
        var bulDebug = false;
        var butControls = true;
        
        if (bulStats) {
            var objStats = new Stats();

            objStats.setMode(0); // 0: fps, 1: ms
            objStats.domElement.style.position = 'absolute';
            objStats.domElement.style.left = '0px';
            objStats.domElement.style.top = '0px';

            document.getElementById("divStats").appendChild(objStats.domElement);
        }

        sceMain = new THREE.Scene();
        camMain = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        renMain = new THREE.WebGLRenderer();
        
        //renMain.setClearColorHex(); 
        renMain.setClearColor(new THREE.Color(0x9999ff, 1.0));
        renMain.setSize(window.innerWidth, window.innerHeight);
        
        //CIEÅƒ
        if (!bulDebug) {
            renMain.shadowMapEnabled = true;
        }
        //LINIA POMOCNICZA
        //x = czerwony
        //y = zielony
        //z = niebieski
        if (bulDebug) {
            var axeLines = new THREE.AxisHelper(20);
            sceMain.add(axeLines);
        }

        //ZIEMIA
        var geoEarth = new THREE.PlaneGeometry(100, 50);
        var matEarth = new THREE.MeshBasicMaterial({color: 0xcccccc});
        var mshEarth = new THREE.Mesh(geoEarth, matEarth);
        mshEarth.rotation.x = -0.5 * Math.PI;
        mshEarth.position.x = 20;
        mshEarth.position.y = -30;
        mshEarth.position.z = 0;
        if (!bulDebug) {
            mshEarth.receiveShadow = true;
        }
        sceMain.add(mshEarth);

        //STOK
        var geoSlope = new THREE.CylinderGeometry( 5, 5, 20, 9 );
		var matSlope;
        if (bulDebug) {
            matSlope = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
        } else {
            matSlope = new THREE.MeshBasicMaterial( { color: 0xdddddd } );
        }
		var mshSlope = new THREE.Mesh(geoSlope, matSlope);
        mshSlope.rotation.x = -0.5 * Math.PI;
        mshSlope.position.x = 0; //-4;
        mshSlope.position.y = 0; //3;
        mshSlope.position.z = 0;
        if (!bulDebug) {
            mshSlope.receiveShadow = true;
            mshSlope.castShadow = true;
        }
        //sceMain.add(mshSlope);
        
        //DRZEWO
        /*
        var rectLength = 5, rectWidth = 10;
		var shpTree = new THREE.Shape();
		shpTree.moveTo( 0, 0 );
		shpTree.lineTo( 0, rectWidth );
		shpTree.lineTo( rectLength, rectWidth );
		shpTree.lineTo( rectLength, 0 );
		shpTree.lineTo( 0, 0 );
		var geoTree = new THREE.ShapeGeometry(shpTree);
        var matTree;
        if (bulDebug) {
            matTree = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
        } else {
            matTree = new THREE.MeshBasicMaterial( { color: 0xaaaaaa } );
        }
        var mshTree = new THREE.Mesh(geoTree, matTree);
        mshTree.rotation.y = -0.5 * Math.PI;
        mshTree.position.x = -4;
        mshTree.position.y = 6;
        mshTree.position.z = -5;
        if (!bulDebug) {
            mshTree.castShadow = true;
        }
        */
        
        var boxTree = new THREE.BoxGeometry(0.1, 10, 5);
        if (bulDebug) {
            matTree = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
        } else {
            matTree = new THREE.MeshBasicMaterial( { color: 0xaaaaaa } );
        }
        var mshTree = new THREE.Mesh(boxTree, matTree);
        mshTree.position.y = 10;
        mshTree.position.z = -5;
        if (!bulDebug) {
            mshTree.castShadow = true;
        }
        
        var boxTree2 = new THREE.BoxGeometry(0.1, 10, 5);
        if (bulDebug) {
            matTree2 = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
        } else {
            matTree2 = new THREE.MeshBasicMaterial( { color: 0xaaaaaa } );
        }
        var mshTree2 = new THREE.Mesh(boxTree2, matTree2);
        mshTree2.position.y = -10;
        mshTree2.position.z = 5;
        if (!bulDebug) {
            mshTree2.castShadow = true;
        }
        
        
        //sceMain.add(mshTree);

        var grMountain = new THREE.Group();        
        grMountain.add(mshSlope);
        grMountain.add(mshTree);
        grMountain.add(mshTree2);
        sceMain.add(grMountain);

        camMain.position.x = -30 - 50;
        camMain.position.y = 40 + 50;
        camMain.position.z = 30 + 50;
        
        /*
        camMain.position.x = -6;
        camMain.position.y = 15;
        camMain.position.z = 0;
        */
        
        camMain.lookAt(sceMain.position);
        
        if (!bulDebug) {
            //var ambientLight = new THREE.AmbientLight(0x0c0c0c);
            //sceMain.add(ambientLight);
            
            var ligSun = new THREE.SpotLight(0xffffff);
            ligSun.position.set(-40, 60, -10);
            ligSun.castShadow = true;
            sceMain.add(ligSun);
        }
        
        document.getElementById("divGame").appendChild(renMain.domElement);

        var controls = new function () {
            this.rotationSpeed = 0.02;
            //this.bouncingSpeed = 0.03;
        };
            
        if (butControls) {
            var gui = new dat.GUI();
            gui.add(controls, 'rotationSpeed', 0, 0.5);
            //gui.add(controls, 'bouncingSpeed', 0, 0.5);
        }

        renderScene();

        function renderScene() {
            if (bulStats) {
                objStats.update();
            }
            //mshSlope.rotation.y += controls.rotationSpeed;
            //mshTree.rotation.y += controls.rotationSpeed;
            
            grMountain.rotation.z += controls.rotationSpeed;
            
            requestAnimationFrame(renderScene);
            renMain.render(sceMain, camMain);
        }
        
    }
    
    function onResize() {
        camMain.aspect = window.innerWidth / window.innerHeight;
        camMain.updateProjectionMatrix();
        renMain.setSize(window.innerWidth, window.innerHeight);
    }
    
    window.onload = init;

    window.addEventListener('resize', onResize, false); 
</script>
</body>
</html>
